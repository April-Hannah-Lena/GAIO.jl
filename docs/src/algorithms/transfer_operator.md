# Transfer Operator

### Mathematical Background
The transition matrix is the discretization of the _transfer operator ``P`` w.r.t. ``f``_. Formally, the transfer operator w.r.t. ``f`` is defined for measures ``μ`` through the equation
```math
P\mu(A) = \mu (f^{-1}(A)) \quad \text{for any} \ \ A \ \ \text{measurable}
```
We will use a Galerkin approximation for ``P`` which maintains the eigenvalues and cyclic behavior of ``P``. To do this, we project to a subspace ``\chi_B`` generated by the basis ``\left\{ \chi_b\ \vert\ b \in B \right\}`` 
of unit measures supported on the boxes of our box set ``B``. Further, we enumerate the box set ``B = {b_1, b_2, ..., b_n}`` with integer indices and define the _transition matrix_ 
```math
    (P^n)_{ij} = \frac{m\left(b_j \cap f^{-1}(b_i)\right)}{m(b_j)}, \quad i,\, j = 1, \ldots, n,
```
where ``m`` is the lebesque measure. Finally, we define the approximate transfer operator ``Q_n P : \chi_B \to \chi_B`` as the linear extension of 
```math
    (Q_n P)\, \chi_{b_i} = \sum_{j = 1}^n P_{ij}^n\, \chi_{b_j}, \quad i = 1, \ldots, n.
```
The operator ``Q_n P`` can be created in GAIO.jl by calling 
```julia
T = TransferOperator(F, B)
```
where `F` is a `BoxMap` and `B` is a box set. In this case, the codomain is generated automatically. This is not always ideal, so the codomain can be specified as an argument
```julia
T = TransferOperator(F, B, B)
```
`T` acts as a matrix in every way, but the explicit transition matrix ``P^n_{ij}`` can be generated by calling 
```julia
M = Matrix(T)
```
It is important to note that `TranferOperator` is only supported over the box set `B`, but if one lets a `TranferOperator` act on a `BoxFun` vie multiplication (see the example), then the support `B` is extended "on the fly" to include the support of the `BoxFun`.

```@docs
TransferOperator
BoxFun
sum(::Any, ::BoxFun)
∘(f, boxfun::BoxFun)
```

### Example : Invariant Measure of the Lorenz Attractor

```@example 1
using GAIO

# the Lorenz system
const σ, ρ, β = 10.0, 28.0, 0.4
v((x,y,z)) = (σ*(y-x), ρ*x-y-x*z, x*y-β*z)
f(x) = rk4_flow_map(v, x)

center, radius = (0,0,25), (30,30,30)
P = BoxPartition(Box(center, radius), (256,256,256))
F = BoxMap(f, P)

x = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)         # equilibrium
S = cover(P, x)
W = unstable_set(F, S)

T = TransferOperator(F, W, W)
(λ, ev) = eigs(T)
μ = log ∘ abs ∘ ev[1]
```

```@example 1
using GLMakie: Figure, Axis3, plot!, Colorbar
fig = Figure();
ax = Axis3(fig[1,1], azimuth=pi/10);
ms = plot!(ax, μ, colormap=:jet);
Colorbar(fig[1,2], ms);

using GLMakie: save # hide
save("transfer_operator.png", fig); nothing # hide
```

![Invariant Measure of the Lorenz Attractor](transfer_operator.png)

### Example 2: Showcase of `BoxFun` Functionalities

```julia
using GAIO

# the unit box [-1, 1]²
domain = Box((0.0, 0.0), (1.0, 1.0))
partition = BoxPartition(domain, (16,8))

# left / right halves of the domain
left  = cover(partition, Box((-0.5, 0.0), (0.5, 1.0)))
right = cover(partition, Box((0.5, 0.0), (0.5, 1.0)))
full  = cover(partition, :)

# create measures with constant weight 1 per box
n = length(left)
μ_left  = BoxFun(left, ones(n))
μ_right = BoxFun(right, ones(n))
μ_full  = BoxFun(full, ones(2n))

# vector space operations are supported for measures
μ_left + μ_right     ==  μ_full
μ_full - μ_left      ==  μ_right
μ_left - μ_full      == -μ_right
2*μ_left + 2*μ_right ==  μ_full + μ_full
μ_left/2 + μ_right/2 ==  μ_full/2

# horizontal translation map
f((x, y)) = (x+1, y)

# BoxMap which uses one sample point in the center of each box
F = BoxMap(:sampled, f, domain, center, center)

# compute the transfer operator over the domain
T = TransferOperator(F, full, full)

# Compute the pushforward / pullback measures by using the transfer operator
T*μ_left  == μ_right
T'μ_right == μ_left

# integration w.r.t. the measures
μ_full(domain) == volume(domain)

g(x) = 2
sum(g, μ_full) == 2*volume(domain)

(2*μ_full)(domain) == 2*volume(domain)

μ_full2 = (x -> 2x) ∘ μ_full
μ_full2(domain) == 2*volume(domain)
```
