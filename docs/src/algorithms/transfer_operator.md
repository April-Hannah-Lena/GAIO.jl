# Transfer Operator and Box Measures

### Mathematical Background

The following description is given in [entropic](@cite).

The _transfer operator_ ``f_{\#}`` _w.r.t._ ``f`` is defined for measures ``μ`` through the equation
```math
(f_{\#}\,\mu) (A) = \mu (f^{-1}(A)) \quad \text{for any} \ \ A \ \ \text{measurable}
```
This is a bounded linear operator on the space of finite signed measures. 
We will use an approximation for ``f_{\#}`` which maintains the eigenvalues and cyclic behavior of ``f_{\#}`` commonly known as _Ulam's method_. In particular we are interested in measures which satisfy ``f_{\#}\,\mu = \mu``, called _invariant_ under ``f``. 

We enumerate the box set ``B = \{ b_1, b_2, ..., b_n \}`` with integer indices and parameterize an _approximate_ invariant measure
```math
    \mu(C) = \sum_{j = 1}^n h_j \frac{m(b_j \cap C)}{m(b_j)} \quad
    \text{for nonnegative coefficients}\ h_1, \ldots, h_n
```
where ``m`` is the Lebesgue measure. We enforce the condition ``f_{\#}\,\mu = \mu`` on the box set ``B``:
```math
    h_j = \mu (b_j) \overset{!}{=} (f_{\#}\,\mu) (b_j) = \sum_{k=1}^n T_{jk} \cdot h_k \quad
    \Rightarrow \quad \text{coefficients}\ T_{jk} := \frac{m(b_k \cap f^{-1} (b_j))}{m(b_k)} . 
```
The resulting matrix elements ``T_{jk}`` gives the (conditional) probability that ``f`` maps a point from ``b_k`` to ``b_j``.

The operator approximation ``F♯`` can be created in GAIO.jl by calling 
```julia
F♯ = TransferOperator(F, B)    # `♯` written as \sharp<TAB>
```
where `F` is a `BoxMap` and `B` is a box set. In this case, the codomain is generated automatically. This is not always ideal, so the codomain can be specified as an argument
```julia
F♯ = TransferOperator(F, B, R)
```
where `R` is also a `BoxSet`. 

`F♯` acts as a matrix in every way, but the explicit transfer weights from ``F♯`` can be generated by calling 
```julia
M = Matrix(F♯)
```
It is important to note that `TransferOperator` is only supported over the box set `B`, but if one lets a `TransferOperator` act on a `BoxMeasure` via multiplication (see the example below), then the support `B` is extended "on the fly" to include the support of the `BoxMeasure`.

```@docs; canonical=false
TransferOperator
BoxMeasure
sum(::Any, ::BoxMeasure)
∘(f, boxmeas::BoxMeasure)
```

### Example : Invariant Measure of the Lorenz Attractor

```@example 1
using GAIO

# the Lorenz system
const σ, ρ, β = 10.0, 28.0, 0.4
v((x,y,z)) = (σ*(y-x), ρ*x-y-x*z, x*y-β*z)
f(x) = rk4_flow_map(v, x)

center, radius = (0,0,25), (30,30,30)
P = GridPartition(Box(center, radius), (256,256,256))
F = BoxMap(f, P)

x = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)         # equilibrium
S = cover(P, x)
W = unstable_set(F, S)

F♯ = TransferOperator(F, W, W)
λ, ev = eigs(F♯)

λ
```

```@example 1
μ = log ∘ abs ∘ ev[1]
```

```@example 1
using GLMakie
fig = Figure();
ax = Axis3(fig[1,1], azimuth=pi/10);
ms = plot!(ax, μ, colormap=:jet);
Colorbar(fig[1,2], ms);

using GLMakie: save # hide
save("transfer_operator.png", fig); nothing # hide
```

![Invariant Measure of the Lorenz Attractor](transfer_operator.png)

### Example 2: Showcase of `BoxMeasure` Functionalities

```@example 2
using GAIO

# the box [-1, 1]²
domain = Box((0.0, 0.0), (1.0, 1.0))
partition = GridPartition(domain, (16,8))

# left / right halves of the domain
left  = cover(partition, Box((-0.5, 0.0), (0.5, 1.0)))
right = cover(partition, Box((0.5, 0.0), (0.5, 1.0)))
full  = cover(partition, :)
```

```@example 2
# create measures with constant weight 1 per box
n = length(left)
scale = volume(domain) / 2n
μ_left  = BoxMeasure(left, ones(n) .* scale)
μ_right = BoxMeasure(right, ones(n) .* scale)
μ_full  = BoxMeasure(full, ones(2n) .* scale)
```

```@example 2
# vector space operations are supported for measures
μ_left + μ_right     ==  μ_full
μ_full - μ_left      ==  μ_right
μ_left - μ_full      == -μ_right
2*μ_left + 2*μ_right ==  μ_full + μ_full
μ_left/2 + μ_right/2 ==  μ_full/2
```

```@example 2
# horizontal translation map
f((x, y)) = (x+1, y)

# BoxMap which uses one sample point in the center of each box
F = BoxMap(:sampled, f, domain, center, center)

# compute the transfer operator over the domain
T = TransferOperator(F, full, full)
```

```@example 2
# Compute the pushforward / pullback measures by using the transfer operator
T*μ_left  == μ_right
T'μ_right == μ_left
```

```@example 2
μ_full(domain) == volume(domain)
```

```@example 2
# integration w.r.t. the measures
g(x) = 2
sum(g, μ_full) == 2*volume(domain)
```

```@example 2
# vector space operations
(2*μ_full)(domain) == 2*volume(domain)
```

```@example 2
# composition of measures with scalar functions
μ_full2 = (x -> 2x) ∘ μ_full
μ_full2(domain) == 2*volume(domain)
```
