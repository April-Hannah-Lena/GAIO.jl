# Transfer Operator

### Mathematical Background
The transition matrix is the discretization of the _transfer operator ``P`` w.r.t. ``f``_. Formally, the transfer operator w.r.t. ``f`` is defined for measures ``μ`` through the equation
```math
P\mu(A) = \mu (f^{-1}(A)) \quad \text{for any} \ \ A \ \ \text{measurable}
```
We will use a Galerkin approximation for ``P`` which maintains the eigenvalues and cyclic behavior of ``P``. To do this, we project to a subspace ``\chi_B`` generated by the basis ``\left\{ \chi_b\ \vert\ b \in B \right\}`` 
of unit measures supported on the boxes of our box set ``B``. Further, we enumerate the box set ``B = {b_1, b_2, ..., b_n}`` with integer indices and define the _transition matrix_ 
```math
    (P^n)_{ij} = \frac{m\left(b_j \cap f^{-1}(b_i)\right)}{m(b_j)}, \quad i,\, j = 1, \ldots, n,
```
where ``m`` is the lebesque measure. Finally, we define the approximate transfer operator ``Q_n P : \chi_B \to \chi_B`` as the linear extension of 
```math
    (Q_n P)\, \chi_{b_i} = \sum_{j = 1}^n P_{ij}^n\, \chi_{b_j}, \quad i = 1, \ldots, n.
```
The operator ``Q_n P`` can be created in GAIO.jl by calling 
```julia
T = TransferOperator(F, B)
```
where `F` is a `BoxMap` and `B` is a box set. In this case, the codomain is generated automatically. This is not always ideal, so the codomain can be specified as an argument
```julia
T = TransferOperator(F, B, B)
```
`T` acts as a matrix in every way, but the explicit transition matrix ``P^n_{ij}`` can be generated by calling 
```julia
M = Matrix(T)
```
It is important to note that `TranferOperator` is only supported over the box set `B`, but if one lets a `TranferOperator` act on a `BoxFun` vie multiplication (see the example), then the support `B` is extended "on the fly" to include the support of the `BoxFun`.

```@docs
TransferOperator
BoxFun
sum(::Any, ::BoxFun)
∘(f, boxfun::BoxFun)
```

### Example

```@repl
using GAIO

# the unit box [-1, 1]²
domain = Box((0.0, 0.0), (1.0, 1.0))
partition = BoxPartition(domain, (16,8))

# left / right halves of the domain
left  = cover(partition, Box((-0.5, 0.0), (0.5, 1.0)))
right = cover(partition, Box((0.5, 0.0), (0.5, 1.0)))
full  = cover(partition, :)

# create measures with constant weight 1 per box
n = length(left)
μ_left  = BoxFun(left, ones(n))
μ_right = BoxFun(right, ones(n))
μ_full  = BoxFun(full, ones(2n))

# vector space operations are supported for measures
μ_left + μ_right == μ_full
μ_full - μ_left == μ_right
μ_left - μ_full == -μ_right
2*μ_left + 2*μ_right == μ_full + μ_full
μ_left/2 + μ_right/2 == μ_full/2

# horizontal translation map
f((x, y)) = (x+1, y)

# BoxMap which uses one sample point in the center of each box
F = BoxMap(:sampled, f, domain, center, center)

# compute the transfer operator over the domain
T = TransferOperator(F, full, full)

# Compute the pushforward / pullback measures by using the transfer operator
T*μ_left  == μ_right
T'μ_right == μ_left

# integration w.r.t. the measures
μ_full(domain) == volume(domain)

g(x) = 2
sum(g, μ_full) == 2*volume(domain)

(2*μ_full)(domain) == 2*volume(domain)
```
