<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · GAIO.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GAIO.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#The-Relative-Global-Attractor"><span>The Relative Global Attractor</span></a></li><li><a class="tocitem" href="#unstable_set"><span>unstable_set</span></a></li><li><a class="tocitem" href="#transition_matrix"><span>transition_matrix</span></a></li><li><a class="tocitem" href="#chain*recurrent*set"><span>chain<em>recurrent</em>set</span></a></li><li><a class="tocitem" href="#root_covering"><span>root_covering</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms-and-Mathematical-Background"><a class="docs-heading-anchor" href="#Algorithms-and-Mathematical-Background">Algorithms and Mathematical Background</a><a id="Algorithms-and-Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-and-Mathematical-Background" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the following, <span>$f$</span> will always refer to the map describing the dynamics of a system, while <span>$g$</span> will be the corresponding <code>BoxMap</code>.</p></div></div><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ul><li><a href="#Algorithms-and-Mathematical-Background">Algorithms and Mathematical Background</a></li><ul><li><a href="#Table-of-Contents">Table of Contents</a></li><li><a href="#The-Relative-Global-Attractor">The Relative Global Attractor</a></li><li><a href="#unstable_set">unstable_set</a></li><li><a href="#transition_matrix">transition_matrix</a></li><li><a href="#chain*recurrent*set">chain<em>recurrent</em>set</a></li><li><a href="#root_covering">root_covering</a></li></ul></ul><h2 id="The-Relative-Global-Attractor"><a class="docs-heading-anchor" href="#The-Relative-Global-Attractor">The Relative Global Attractor</a><a id="The-Relative-Global-Attractor-1"></a><a class="docs-heading-anchor-permalink" href="#The-Relative-Global-Attractor" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">Relative Global Attractor</header><div class="admonition-body"><p>Consider a time discrete dynamical system induced by the diffeomorphism <span>$g: \mathbb{R}^d \to \mathbb{R}^d$</span>. Let <span>$Q \subset \mathbb{R}^d$</span> compact. The set </p><div>\[A_Q := \bigcap_{k \leq 0} g^k(Q)\]</div><p>is called the global attractor relative to <span>$Q$</span>.</p></div></div><p>The relative global attractor can be seen as the set which is eventually approached by every orbit originating in <span>$Q$</span>. In particular, <span>$A_Q$</span> contains each invariant set in <span>$Q$</span> and therefore all the potentially interesting dynamics. Thus it is of great interest to be able to compute a relative global attractor numerically.  The idea of the algorithm is to cover the relative global attractor with boxes and recursively tighten the covering by refining appropriately selected boxes.</p><h3 id="Mathematical-Background-of-the-Algorithm"><a class="docs-heading-anchor" href="#Mathematical-Background-of-the-Algorithm">Mathematical Background of the Algorithm</a><a id="Mathematical-Background-of-the-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-of-the-Algorithm" title="Permalink"></a></h3><p>Mathematically, the algorithm to compute the global attractor relative to <span>$Q$</span> takes two input arguments: a compact set <span>$Q$</span> as well as a map <span>$f$</span>, which describes the dynamics. Now in each iteration, two steps happen:</p><ol><li><strong>subdivision-step:</strong> The domain <span>$B_{k-1}$</span> is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, <span>$\hat{B}_k$</span>, with double the amount of boxes.</li><li><strong>selection_step:</strong> For each box <span>$B$</span> of the new partition we check, if there is another Box <span>$B&#39;$</span> that is mapped into <span>$B$</span> under <span>$g$</span>, i.e. if <span>$f(B&#39;) \cap B \neq \emptyset$</span>. If not, we remove <span>$B$</span> from the domain.</li></ol><p>After removing every non-hit box, we arrive at the new domain <span>$B_k$</span>, and as <span>$k \to \infty$</span>, the collection of boxes <span>$B_k$</span> converges to the relative global attractor <span>$A_Q$</span>.</p><h3 id="Implementation-of-the-Algorithm"><a class="docs-heading-anchor" href="#Implementation-of-the-Algorithm">Implementation of the Algorithm</a><a id="Implementation-of-the-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-the-Algorithm" title="Permalink"></a></h3><p>So, how was taken care of the discretization, which is necessary for the implementation? In other words, how did we translate this Algorithm into GAIO?</p><pre><code class="language-julia">function relative_attractor(boxset::BoxSet, g::BoxMap, depth::Int)
    for k = 1:depth
        boxset = subdivide(boxset)
        boxset = g(boxset; target=boxset)
    end

    return boxset
end</code></pre><p>The first thing one notices is that the implementation has a third input parameter <code>depth</code>, which describes the level of approximation. Since in each step of the algorithm the initial domain is divided in half, the final partition after <code>depth</code> many steps will contain <span>$n := 2^{\text{depth}}$</span> boxes, i.e. every box in the final covering is <span>$\frac{1}{n}$</span> times the size of the initial box. Besides <code>depth</code> we have the input parameters <code>boxset</code> and <code>g</code>, which is the <code>BoxMap</code> describing the dynamics, that is a function which maps boxes to boxes. <code>g</code> is going to be implemented as a <code>PointDiscretizedMap</code>, which is a <code>struct</code> containing the underlying pointwise map corresponding to the dynamics as well as the set of reference points, implemented as an <code>Array</code> of <code>Tuple</code>s, that will be the discretization of a box.</p><pre><code class="language-julia">struct PointDiscretizedMap{F,P} &lt;: BoxMap
    f::F
    points::P
end</code></pre><p><code>boxset</code> is <code>struct</code>, which carries both a set and the partition of the set, that is the information about the size of each single box in the set.</p><pre><code class="language-julia">struct BoxSet{P &lt;: BoxPartition,S &lt;: AbstractSet}
    partition::P
    set::S
end</code></pre><p>For this algorithm the partition needs to be the full regular partition of the initial set (i.e. the starting domain). Now, for each step in the algorithm, the current set is subdivided via the subdivision algorithm:</p><pre><code class="language-julia">boxset = subdivide(boxset)</code></pre><p>And it is checked, if a box is hit by another box under the dynamics:</p><pre><code class="language-julia">function map_boxes_with_target(g, source::BoxSet, target::BoxSet)
    result = boxset_empty(target.partition)

    for (_, hit) in ParallelBoxIterator(g, source, target.partition)
        if hit !== nothing # check that point was inside domain
            if hit in target.set
                push!(result.set, hit)
            end
        end
    end

    return result
end</code></pre><p>where implementationally we start with an empty boxset and store each box that is hit in it.</p><hr/><h2 id="unstable_set"><a class="docs-heading-anchor" href="#unstable_set">unstable_set</a><a id="unstable_set-1"></a><a class="docs-heading-anchor-permalink" href="#unstable_set" title="Permalink"></a></h2><p>In the following we are presenting the algorithm to cover invariant manifolds within some domain <span>$Q$</span> (which has to contain a fixed point).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For simplicity, we will explain the algorithm for the case of the <em>unstable manifold</em>. However one can compute the stable manifold as well by considering the boxmap describing the inverse map <span>$f^{-1}$</span> as input argument for the algorithm.</p></div></div><p>Usually, the computation of the unstable manifold is relatively simple in 1D, but the higher the dimension, the more complicated it becomes. GAIO is able to compute the unstable manifold for arbitrary dimension.</p><h3 id="Mathematical-Background-of-the-Algorithm-2"><a class="docs-heading-anchor" href="#Mathematical-Background-of-the-Algorithm-2">Mathematical Background of the Algorithm</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-of-the-Algorithm-2" title="Permalink"></a></h3><p>The unstable manifold is defined as</p><blockquote><p>[Pretty definition]</p></blockquote><p>The idea behind the algorithm to compute the unstable manifold can be explained in two steps. Before starting we need to identify a hyperbolic fixed point and the region <span>$Q$</span>, which we are going to compute the manifold in. The region <span>$Q$</span> needs to be already partitioned into small boxes.</p><ol><li>Since a fixed point is always part of the unstable manifold, we need to identify a small region/box containing this fixed point.</li><li>The small box containing the fixed point is then mapped forward under the dynamics defined by <span>$f$</span> and the boxes that are hit under the image are added to the box collection. Then those newly included boxes are mapped forward and the procedure is repeated. </li></ol><p>With these two steps we obtain a covering of part of the global unstable manifold.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>One might not be able to compute the parts of the unstable manifold whose preimage lies outside the domain <span>$Q$</span>. Thus, it is important to choose <span>$Q$</span> large enough.</p></div></div><p>How was this algorithm translated into the language of GAIO?</p><h3 id="Implementation-of-the-Algorithm-2"><a class="docs-heading-anchor" href="#Implementation-of-the-Algorithm-2">Implementation of the Algorithm</a><a class="docs-heading-anchor-permalink" href="#Implementation-of-the-Algorithm-2" title="Permalink"></a></h3><pre><code class="language-julia">function unstable_set!(boxset::BoxSet, g::BoxMap)
    boxset_new = boxset

    while !isempty(boxset_new)
        boxset_new = g(boxset_new)

        setdiff!(boxset_new, boxset)
        union!(boxset, boxset_new)
    end

    return boxset
end</code></pre><p>Let us start with the input arguments for the algorithm: Again, like in the relative attractor Algorithm from above, <span>$g$</span> is the <code>BoxMap</code> describing the underlying dynamics <span>$f$</span>. It thus stores <span>$f$</span> and a set of reference points necessary for the discretization of the boxes. The other input argument <span>$boxset$</span> includes two things:</p><ol><li>The domain <span>$Q$</span> we are going to compute the unstable manifold in (<span>$Q$</span> can be implemented as a large <code>Box</code>) and the underlying partition of the domain. Unlike in the previous algorithm, the domain will not be subdivided along the algorithms course, but we need to pass a partition which is already subdivided to the depth <span>$d$</span> (and therefore the level of accuracy) we want our final boxcovering to have.</li><li>Since <code>boxset</code> is going to store all the new boxes we aquire in every iteration of the algorithm, it has to be initialized containing no other box than the single box of size <span>$\frac{1}{2^d}$</span> around the fixed point that is part of the unstable manifold we intend to compute.</li></ol><p>Note: This algorithm works with two mutable sets of boxes: <code>boxset</code>, which collects the boxes we aquire in each iteration and will eventually cover part of the unstable manifold, and <code>boxset_new</code>, which will be overwritten in each iteration and contains only the boxes which will be newly added to our collection. To initialize, we set</p><pre><code class="language-julia">boxset_new = boxset</code></pre><p>Now we repeat the following steps:  First, we map the newly aquired boxes one step forward in time</p><pre><code class="language-julia">boxset_new = g(boxset_new)</code></pre><p>Note: Mapping only the newly aquired boxes from the previous step saves memory and computation time since we already computed the images of the old boxes in previous steps and thus those boximages are already part of the collector <code>boxset</code>. Now we need to update <code>boxset_new</code> and <code>boxset</code>. As mentioned prior, we only want to consider boxes in each iteration step, that have not been &#39;hit&#39; under <code>g</code> by any boxes we aquired in a previous iteration step, because that would mean that this box image already is part of our box collection. To differ between truly new boxes and boxes we already added, we take the setdifference between the images of boxes <code>boxset_new</code> and the whole boxcollection <code>boxset</code>:</p><pre><code class="language-julia">setdiff!(boxset_new, boxset)</code></pre><p>Now <code>boxset_new</code> contains nothing but the truly new boxes. <code>boxset</code> is then updated by adding those new image boxes to our collection of boxes by forming the union with the already existing collection:</p><pre><code class="language-julia">union!(boxset, boxset_new)</code></pre><p>We repeat these steps as long as</p><pre><code class="language-julia">while !isempty(boxset_new)</code></pre><p>is true. Thus, the iteration will end when no new boxes can be added to the boxcollection, because we e.g. got so close to the border of the domain <span>$Q$</span>, that every further image of boxes lies beyond the border, or the unstable manifold oscillates so strongly, that our chosen level of accuracy can no longer distinguish between the oscillations.</p><hr/><h2 id="transition_matrix"><a class="docs-heading-anchor" href="#transition_matrix">transition_matrix</a><a id="transition_matrix-1"></a><a class="docs-heading-anchor-permalink" href="#transition_matrix" title="Permalink"></a></h2><hr/><h2 id="chain*recurrent*set"><a class="docs-heading-anchor" href="#chain*recurrent*set">chain<em>recurrent</em>set</a><a id="chain*recurrent*set-1"></a><a class="docs-heading-anchor-permalink" href="#chain*recurrent*set" title="Permalink"></a></h2><hr/><h2 id="root_covering"><a class="docs-heading-anchor" href="#root_covering">root_covering</a><a id="root_covering-1"></a><a class="docs-heading-anchor-permalink" href="#root_covering" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../general/">« General usage</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 July 2020 21:10">Monday 13 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
